import { elementAcceptingRef } from '@mui/utils';
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { useState } from 'react';
import measurementService from '../reduxServices/measurementService';

//** REDUX TOOLKIT: SLICE 
//* In this slice-file comments are left for explaining the code structure
//* The API call are extracted to the reduxServices folder

// Define a type for the slice state
interface MeasurementState {
  measurements: IMeasurement[];
  loading: boolean;
  error: string | null;
  message: string | null;
}

// Define the initial state using that type
const initialState: MeasurementState = {
  measurements: [],
  loading: false,
  error: null,
  message: null
};

//** Async function call to API*/
// The function below is called a thunk and allows us to perform async logic.
// It can be dispatched like a regular action: `dispatch(incrementAsync(10))`.
// This will call the thunk with the `dispatch` function as the first argument.
// Async code can then be executed and other actions can be dispatched
export const measurementsFetchAsync = createAsyncThunk(
  'measurement/fetch..',
  async (styleId: string) => {
    var result = await measurementService.fetchMeasurements(styleId);
    // The value we return becomes the `fulfilled` action payload
    return result;
  }
);

// export const measurementCreateAsync = createAsyncThunk(
//   'measurement/create',
//   async (measurement: ICreateMeasurement) => {
//     var result = await measurementService.createMeasurement(measurement);
//     return result;
//   }
// );
export const measurementCreateWithSizeRangeAsync = createAsyncThunk(
  'measurement/create',
  async (measurement: ICreateMeasurement) => {
    var result = await measurementService.createMeasurementAndSizeRange(measurement);
    return result;
  }
);

export const measurementSlice = createSlice({
  name: 'measurement',
  initialState,
  reducers: {
    // Redux Toolkit allows us to write "mutating" logic in reducers. It
    // doesn't actually mutate the state because it uses the immer library,
    // which detects changes to a "draft state" and produces a brand new
    // immutable state based off those changes
    measurementResetMessages: (state) => {
      state.error = null;
      state.message = null;
    },
    measurementSortedByCreatedDate: (state) => {
      // ✅ Sort in Ascending order (low to high)
      if (state.measurements.length > 1) state.measurements.sort((a: IMeasurement, b: IMeasurement) => (a.createdDate as any) - (b.createdDate as any));
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      // FETCH ALL
      .addCase(measurementsFetchAsync.pending, state => {
        console.log("Log: measurementSlice.ts metod measurementFetchAsync. Status PENDING");
        state.loading = true;
        state.error = null;
        state.message = null;
      })
      .addCase(measurementsFetchAsync.fulfilled, (state, action) => {

        //Load state.Measurement by id. If new id, add. If excisting id, update.      //TODO: Skriv test för denna metod !!
        console.log("Log: measurementSlice.ts metod measurementFetchAsync. Status FULFILLED");
        //NOTE: ERROR: Uncaught (in promise) TypeError: action.payload.forEach is not a function  (men funka innan jag jobbad djupare?)
        Array.from(action.payload).forEach((item) => {
          var index = state.measurements.findIndex(x => x.id == item.id);
          if (index != -1) {
            state.measurements.splice(index, 1, item);
          }
          else {
            state.measurements.push(item);
          }
        });
        measurementSortedByCreatedDate();  // TODO: Kolla att det funkar som önskat...!
        state.loading = false;
        state.error = null;
        state.message = null;
      })
      .addCase(measurementsFetchAsync.rejected, (state, action) => {
        console.log("Log: measurementSlice.ts metod measurementFetchAsync. Status REJECTED");
        state.loading = false;
        if (action.payload) {
          state.error = action.payload as string;
        } else {
          state.error = 'Failed to fetch measurements';
        }
        state.message = null;
      })
      // CREATE one
      .addCase(measurementCreateWithSizeRangeAsync.pending, (state) => {
        state.loading = true;
        state.error = null;
        state.message = null;
      })
      .addCase(measurementCreateWithSizeRangeAsync.fulfilled, (state, action) => {
        state.measurements.push(action.payload);
        state.loading = false;
        state.error = null;
        state.message = null;
      })
      .addCase(measurementCreateWithSizeRangeAsync.rejected, (state, action) => {
        state.loading = false;
        if (action.payload) {
          state.error = action.payload as string;
        } else {
          state.error = 'Failed to create measurement';
        }
        state.message = null;
      });
  }
});

export const { measurementResetMessages, measurementSortedByCreatedDate } = measurementSlice.actions;

export default measurementSlice.reducer;